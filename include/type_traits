#pragma once

namespace std {


//
// add_const
//
template<class T>
struct add_const
{
	using type = const T;
};


template<class T>
using add_const_t = typename add_const<T>::type;



//
// add_lvalue_reference
//
template<class T>
struct add_lvalue_reference
{
	using type = T&;
};


template<class T>
struct add_lvalue_reference<T&&>
{
	using type = T&;
};


template<class T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;



//
// add_rvalue_reference
//
template<class T>
struct add_rvalue_reference
{
	using type = T&&;
};


template<class T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;



//
// remove_reference
//
template<bool Cond, class T, class F>
struct conditional
{
	using type = T;
};


template<class T, class F>
struct conditional<false, T, F>
{
	using type = F;
};


template<bool Cond, class T, class F>
using conditinal_t = typename conditional<Cond, T, F>::type;


/*

//
// is_constructible
// FIXME: check correctness
//
namespace details {

template<class, class T, class... Args>
struct _is_constructible:
	public false_type
	{};

template<class T, class... Args>
struct _is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...>
	: public true_type
	{};

} // namespace details


template <class T, class... Args>
using is_constructible = details::_is_constructible<void_t<>, T, Args...>;

*/

//
// remove_reference
//
template<class T>
struct remove_reference
{
	using type = T;
};


template<class T>
struct remove_reference<T&>
{
	using type = T;
};


template<class T>
struct remove_reference<T&&>
{
	using type = T;
};


template<class T>
using remove_reference_t = typename remove_reference<T>::type;


//
// void_t
//
template<class...>
using void_t = void;



#if 0
template<typename From, typename To>
struct is_convertible;

template<typename From, typename To, To* guard = declval(From *)>
struct is_convertible: public true_type {};

template<typename From, typename To>
struct is_convertible: public false_type {};


template<typename From, typename To>
struct is_convertible;


template<typename From, typename To>
constexpr bool is_convertible_v = is_convertible<From, To>::value;

#endif


} // namespace std

