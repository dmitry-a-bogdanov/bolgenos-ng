#pragma once

#include <cstddef>

#include "impl/type_traits/integral_constant.hpp"
#include "impl/type_traits/is_signed.hpp"
#include "impl/type_traits/is_unsigned.hpp"
#include "impl/type_traits/enable_if.hpp"
#include "impl/type_traits/make_signed.hpp"
#include "impl/type_traits/make_unsigned.hpp"

namespace std {


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// void_t
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class...>
using void_t = void;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// add_const
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
struct add_const
{
	using type = const T;
};


template<class T>
using add_const_t = typename add_const<T>::type;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// add_lvalue_reference
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
struct add_lvalue_reference
{
	using type = T&;
};


template<class T>
struct add_lvalue_reference<T&&>
{
	using type = T&;
};


template<class T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// add_rvalue_reference
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
struct add_rvalue_reference
{
	using type = T&&;
};


template<class T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;




///////////////////////////////////////////////////////////////////////////////////////////////////
//
// remove_reference
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
struct remove_reference
{
	using type = T;
};


template<class T>
struct remove_reference<T&>
{
	using type = T;
};


template<class T>
struct remove_reference<T&&>
{
	using type = T;
};


template<class T>
using remove_reference_t = typename remove_reference<T>::type;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// declval
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
typename std::add_rvalue_reference<T>::type declval() noexcept;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// conditional
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<bool Cond, class T, class F>
struct conditional
{
	using type = T;
};


template<class T, class F>
struct conditional<false, T, F>
{
	using type = F;
};


template<bool Cond, class T, class F>
using conditinal_t = typename conditional<Cond, T, F>::type;



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// is_same
//
///////////////////////////////////////////////////////////////////////////////////////////////////
template<class T1, class T2>
struct is_same: public false_type {};


template<class T>
struct is_same<T, T>: public true_type {};


template<class T1, class T2>
constexpr bool is_same_v = is_same<T1, T2>::value;


} // namespace std



