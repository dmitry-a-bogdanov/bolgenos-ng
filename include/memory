#pragma once


#include "cstddef"
#include "utility"

namespace std {


template<typename T>
struct default_delete
{
public:
	constexpr default_delete() = default;

	template <typename U>
	default_delete(const default_delete<U>&) {}

	void operator()(T* ptr)
	{
		delete ptr;
	}
};


template<typename T>
struct default_delete<T[]>
{
public:
	constexpr default_delete() = default;

	template <typename U>
	default_delete(const default_delete<U[]>&) {}

	void operator()(T* ptr)
	{
		delete[] ptr;
	}
};



template<typename T, typename Deleter = std::default_delete<T>>
class unique_ptr
{
public:
	using pointer = T*;
	using deleter_type = Deleter;


	constexpr unique_ptr() noexcept = default;


	constexpr unique_ptr(nullptr_t) noexcept
		: _object{nullptr} {}


	explicit unique_ptr(pointer p) noexcept
		: _object{p} {}


	unique_ptr(const unique_ptr&) = delete;


	unique_ptr(unique_ptr&& other) noexcept
	{
		swap(_object, other._object);
		swap(_deleter, other._deleter);
	}


	~unique_ptr()
	{
		if (_object)
		{
			get_deleter()(get());
		}
	}


	unique_ptr& operator=(const unique_ptr&) = delete;


	unique_ptr& operator=(unique_ptr&& other) noexcept
	{
		reset(other.release());
		// FIXME: move if noexcept
		_deleter = std::move(other.get_deleter());
		return *this;
	}


	pointer get() const noexcept
	{
		return _object;
	}


	void reset(pointer ptr = pointer()) noexcept
	{
		auto old_ptr = _object;
		_object = ptr;
		if (old_ptr)
		{
			get_deleter()(old_ptr);
		}
	}


	pointer release() noexcept
	{
		pointer old_ptr = _object;
		_object = nullptr;
		return old_ptr;
	}


	deleter_type& get_deleter() noexcept
	{
		return _deleter;
	}


	const deleter_type& get_deleter() const noexcept
	{
		return _deleter;
	}


	pointer operator->() const noexcept
	{
		return get();
	}

private:
	pointer _object{ nullptr };
	deleter_type _deleter{};
};


template<class T, class... Args>
unique_ptr<T> make_unique(Args&& ...args)
{
	return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}


} // namespace std

