#pragma once
#error "Cannot include this header"
#include <string>

namespace std {


template<class CharT, class Traits = std::char_traits<CharT>>
class basic_streambuf
{
public:
	using char_type = CharT;
	using traits_type = Trait;
	using int_type = typename traits_type::int_type;
	using pos_type = typename traits_type::pos_type;
	using off_type = typename traits_type::off_type;

	virtual ~basic_streambuf() = default;


	basic_streambuf* pubsetbuf(char_type *buff, std::streamsize size)
	{
		return this->setbuf(buff, size);
	}

	int pubsync()
	{
		return this->sync();
	}


	int_type sputc(char_type ch)
	{
		if (pptr() == nullptr || pptr() >= epptr())
		{
			return overflow(ch);
		}
		else
		{
			*pptr() = ch;
			pbump(1);
			return traits_type::to_int_type(ch);
		}
	}

	std::streamsize sputn(const char_type *s, std::streamsize count)
	{
		return this->xsputn(s, count);
	}



protected:
	basic_streambuf() = default;
	basic_streambuf(const basic_streambuf& );
	basic_streambuf& operator=(const basic_streambuf& other);

	void swap(basic_streambuf& other);

	char_type* pbase() const
	{
		return _pbase;
	}

	char_type* pptr() const
	{
		return _pptr;
	}

	char_type* epptr() const
	{
		return _epptr;
	}

	void pbump(int count)
	{
		_pptr += count;
	}

	virtual int_type overflow(int_type ch = traits_type::eof())
	{
		return ch;
	}

	virtual basic_streambuf* setbuf(char_type *, std::streamsize)
	{
		return this;
	}

	virtual int sync()
	{
		return 0;
	}

	virtual std::streamsize xsputn(const char_type* s, std::streamsize count)
	{
		for(std::streamsize i = 0; i != count; ++i)
		{
			if (sputc(s[i]) == Traits::eof())
			{
				return i;
			}
		}
		return count;
	}
private:
	char_type *_pbase{ nullptr };
	char_type *_pptr{ nullptr };
	char_type *_epptr{ nullptr };
};


using streambuf = basic_streambuf<char>;


} // namespace std
